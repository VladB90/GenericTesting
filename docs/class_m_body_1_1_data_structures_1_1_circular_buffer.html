<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MBody Library: MBody::DataStructures::CircularBuffer&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MBody Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_m_body.html">MBody</a></li><li class="navelem"><b>DataStructures</b></li><li class="navelem"><a class="el" href="class_m_body_1_1_data_structures_1_1_circular_buffer.html">CircularBuffer</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_m_body_1_1_data_structures_1_1_circular_buffer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">MBody::DataStructures::CircularBuffer&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This is an implementation of a fixed - size overwriting circular buffer. The buffer capacity is specified when the buffer is created. When the buffer's number of elements has reached the capacity, newly pushed elements will overwrite the old elements in a first - in, first - out(FIFO) order.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_circular_buffer_8h_source.html">CircularBuffer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaebccd9a75ac39f4f9b4fb975d214af1" id="r_aaebccd9a75ac39f4f9b4fb975d214af1"><td class="memItemLeft" align="right" valign="top"><a id="aaebccd9a75ac39f4f9b4fb975d214af1" name="aaebccd9a75ac39f4f9b4fb975d214af1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CircularBuffer</b> (int bufferSize)</td></tr>
<tr class="separator:aaebccd9a75ac39f4f9b4fb975d214af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac28905f36300600f5f19a45561585a" id="r_adac28905f36300600f5f19a45561585a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adac28905f36300600f5f19a45561585a">CircularBuffer</a> (int bufferSize, T defaultValue)</td></tr>
<tr class="memdesc:adac28905f36300600f5f19a45561585a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_m_body_1_1_data_structures_1_1_circular_buffer.html" title="This is an implementation of a fixed - size overwriting circular buffer. The buffer capacity is speci...">CircularBuffer</a> constructor that takes an int to instantiate the max buffer size.  <br /></td></tr>
<tr class="separator:adac28905f36300600f5f19a45561585a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aee8e3396719228f695304ffd699e56" id="r_a2aee8e3396719228f695304ffd699e56"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2aee8e3396719228f695304ffd699e56">GetBufferCapacity</a> () const</td></tr>
<tr class="memdesc:a2aee8e3396719228f695304ffd699e56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the capacity of the buffer. When the buffer's number of elements has reached the capacity, newly pushed elements will overwrite old elements (oldest elements overwritten first).  <br /></td></tr>
<tr class="separator:a2aee8e3396719228f695304ffd699e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ae797c1b45a99c59730a4188a262ba" id="r_ad4ae797c1b45a99c59730a4188a262ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4ae797c1b45a99c59730a4188a262ba">Push</a> (const T &amp;elementToPush)</td></tr>
<tr class="memdesc:ad4ae797c1b45a99c59730a4188a262ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push an element to the buffer.  <br /></td></tr>
<tr class="separator:ad4ae797c1b45a99c59730a4188a262ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6ac7b864bc791763ec8d6739e89798" id="r_add6ac7b864bc791763ec8d6739e89798"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add6ac7b864bc791763ec8d6739e89798">Push</a> (const std::vector&lt; T &gt; &amp;elementCollection)</td></tr>
<tr class="memdesc:add6ac7b864bc791763ec8d6739e89798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes a collection of elements to the buffer.  <br /></td></tr>
<tr class="separator:add6ac7b864bc791763ec8d6739e89798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1963d3f0ec84a0da1e195e01984bd28" id="r_ae1963d3f0ec84a0da1e195e01984bd28"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1963d3f0ec84a0da1e195e01984bd28">CopyToBuffer</a> (int offsetFromStart, int lengthToRead, std::vector&lt; T &gt; &amp;destinationBuffer) const</td></tr>
<tr class="memdesc:ae1963d3f0ec84a0da1e195e01984bd28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a section of the circular buffer to a destination buffer.  <br /></td></tr>
<tr class="separator:ae1963d3f0ec84a0da1e195e01984bd28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2faa91661cb4883e18eff87ba19ac4f" id="r_ac2faa91661cb4883e18eff87ba19ac4f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2faa91661cb4883e18eff87ba19ac4f">ResizeBuffer</a> (int newSize, bool wipeCurrentContentsOfBuffer=false)</td></tr>
<tr class="memdesc:ac2faa91661cb4883e18eff87ba19ac4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the buffer to the given size. Optionally can retain content of buffer, but may run into issues if sizing buffer down while retaining data.  <br /></td></tr>
<tr class="separator:ac2faa91661cb4883e18eff87ba19ac4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class T&gt;<br />
class MBody::DataStructures::CircularBuffer&lt; T &gt;</div><p>This is an implementation of a fixed - size overwriting circular buffer. The buffer capacity is specified when the buffer is created. When the buffer's number of elements has reached the capacity, newly pushed elements will overwrite the old elements in a first - in, first - out(FIFO) order. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="adac28905f36300600f5f19a45561585a" name="adac28905f36300600f5f19a45561585a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac28905f36300600f5f19a45561585a">&#9670;&#160;</a></span>CircularBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_body_1_1_data_structures_1_1_circular_buffer.html">MBody::DataStructures::CircularBuffer</a>&lt; T &gt;::CircularBuffer </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>bufferSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>defaultValue</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_m_body_1_1_data_structures_1_1_circular_buffer.html" title="This is an implementation of a fixed - size overwriting circular buffer. The buffer capacity is speci...">CircularBuffer</a> constructor that takes an int to instantiate the max buffer size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufferSize</td><td>The size to make the buffer.</td></tr>
    <tr><td class="paramname">defaultValue</td><td>Default value to fill the buffer with</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae1963d3f0ec84a0da1e195e01984bd28" name="ae1963d3f0ec84a0da1e195e01984bd28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1963d3f0ec84a0da1e195e01984bd28">&#9670;&#160;</a></span>CopyToBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_m_body_1_1_data_structures_1_1_circular_buffer.html">MBody::DataStructures::CircularBuffer</a>&lt; T &gt;::CopyToBuffer </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>offsetFromStart</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>lengthToRead</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>destinationBuffer</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy a section of the circular buffer to a destination buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offsetFromStart</td><td>How far from the start of the data to read from. The start position will always point to the oldest element</td></tr>
    <tr><td class="paramname">end</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the copy was successful</dd></dl>

</div>
</div>
<a id="a2aee8e3396719228f695304ffd699e56" name="a2aee8e3396719228f695304ffd699e56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aee8e3396719228f695304ffd699e56">&#9670;&#160;</a></span>GetBufferCapacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_m_body_1_1_data_structures_1_1_circular_buffer.html">MBody::DataStructures::CircularBuffer</a>&lt; T &gt;::GetBufferCapacity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the capacity of the buffer. When the buffer's number of elements has reached the capacity, newly pushed elements will overwrite old elements (oldest elements overwritten first). </p>
<dl class="section return"><dt>Returns</dt><dd>The buffer capacity.</dd></dl>

</div>
</div>
<a id="add6ac7b864bc791763ec8d6739e89798" name="add6ac7b864bc791763ec8d6739e89798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add6ac7b864bc791763ec8d6739e89798">&#9670;&#160;</a></span>Push() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_m_body_1_1_data_structures_1_1_circular_buffer.html">MBody::DataStructures::CircularBuffer</a>&lt; T &gt;::Push </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>elementCollection</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pushes a collection of elements to the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elementCollection</td><td>The element collection to push to the buffer.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4ae797c1b45a99c59730a4188a262ba" name="ad4ae797c1b45a99c59730a4188a262ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4ae797c1b45a99c59730a4188a262ba">&#9670;&#160;</a></span>Push() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_m_body_1_1_data_structures_1_1_circular_buffer.html">MBody::DataStructures::CircularBuffer</a>&lt; T &gt;::Push </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>elementToPush</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push an element to the buffer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The element to push to the buffer.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2faa91661cb4883e18eff87ba19ac4f" name="ac2faa91661cb4883e18eff87ba19ac4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2faa91661cb4883e18eff87ba19ac4f">&#9670;&#160;</a></span>ResizeBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_m_body_1_1_data_structures_1_1_circular_buffer.html">MBody::DataStructures::CircularBuffer</a>&lt; T &gt;::ResizeBuffer </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>newSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>wipeCurrentContentsOfBuffer</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the buffer to the given size. Optionally can retain content of buffer, but may run into issues if sizing buffer down while retaining data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSize</td><td>New size of the buffer.</td></tr>
    <tr><td class="paramname">wipeCurrentContentsOfBuffer</td><td>Toggle to wipe the contents of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if buffer was successfully resized.</dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>D:/_Companies/Artp/ML_DLL/MachineLearningARTP/<a class="el" href="_circular_buffer_8h_source.html">CircularBuffer.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
